{"ast":null,"code":"var _jsxFileName = \"D:\\\\Usuarios\\\\FRANCO\\\\Desktop\\\\parroquav3\\\\frontend\\\\src\\\\contexts\\\\AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState, useRef, useMemo, useCallback } from 'react';\nimport { useTheme } from './ThemeContext';\nimport { createPortal } from 'react-dom';\nimport { Fragment as _Fragment, jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\n// Evita re-render de la app cuando el Provider cambia estado interno no relevante\nconst ChildrenContainer = /*#__PURE__*/React.memo(_c = ({\n  children\n}) => /*#__PURE__*/_jsxDEV(_Fragment, {\n  children: children\n}, void 0, false));\n_c2 = ChildrenContainer;\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [sessionExpiring, setSessionExpiring] = useState(false);\n  const {\n    setTheme\n  } = useTheme();\n\n  // ‚öôÔ∏è CONFIGURACI√ìN DE TIEMPOS (m√°s legible)\n  // Formato: { minutos: X, segundos: Y }\n  const TIEMPO_CONFIG = {\n    TOKEN_DURACION: {\n      minutos: 1,\n      segundos: 0\n    },\n    // Igual que backend\n    REFRESH_ANTICIPADO: {\n      minutos: 0,\n      segundos: 10\n    },\n    // 10s antes de expirar\n    AVISO_INACTIVIDAD: {\n      minutos: 0,\n      segundos: 45\n    },\n    // Aviso a los 45s\n    LOGOUT_INACTIVIDAD: {\n      minutos: 1,\n      segundos: 0\n    } // Logout a 1 min\n  };\n\n  // üîß Funci√≥n helper para convertir a milisegundos\n  const aMs = config => (config.minutos * 60 + config.segundos) * 1000;\n\n  // Constantes calculadas (NO MODIFICAR)\n  const ACCESS_TOKEN_LIFETIME = aMs(TIEMPO_CONFIG.TOKEN_DURACION);\n  const REFRESH_BEFORE_EXPIRY = aMs(TIEMPO_CONFIG.REFRESH_ANTICIPADO);\n  const INACTIVITY_WARNING = aMs(TIEMPO_CONFIG.AVISO_INACTIVIDAD);\n  const INACTIVITY_TIMEOUT = aMs(TIEMPO_CONFIG.LOGOUT_INACTIVIDAD);\n  const COUNTDOWN_SECONDS = Math.floor((INACTIVITY_TIMEOUT - INACTIVITY_WARNING) / 1000);\n  const [countdown, setCountdown] = useState(COUNTDOWN_SECONDS);\n\n  // üîí REFS para control de estado y prevenci√≥n de race conditions\n  const countdownRef = useRef(null);\n  const inactivityTimerRef = useRef(null);\n  const totalSessionTimerRef = useRef(null);\n  const sessionExpiringRef = useRef(sessionExpiring);\n  const refreshTimerRef = useRef(null);\n  const isRefreshingRef = useRef(false);\n  const refreshPromiseRef = useRef(null);\n  const tokenExpiryTimeRef = useRef(null);\n  const lastActivityTimeRef = useRef(0);\n  useEffect(() => {\n    sessionExpiringRef.current = sessionExpiring;\n  }, [sessionExpiring]);\n\n  // ========================\n  // üü¢ Inicializaci√≥n de sesi√≥n\n  // ========================\n  useEffect(() => {\n    const initializeAuth = async () => {\n      const savedUser = localStorage.getItem('user');\n      const accessToken = localStorage.getItem('access_token');\n      if (savedUser && accessToken) {\n        try {\n          var _parsed$preferences;\n          const parsed = JSON.parse(savedUser);\n          setUser(parsed);\n          // Aplica tema desde preferencias guardadas del usuario (si existen)\n          if (parsed !== null && parsed !== void 0 && (_parsed$preferences = parsed.preferences) !== null && _parsed$preferences !== void 0 && _parsed$preferences.theme) {\n            setTheme(parsed.preferences.theme);\n          }\n        } catch {}\n\n        // Establecer tiempo de expiraci√≥n del token\n        const tokenExpiry = localStorage.getItem('token_expiry');\n        if (tokenExpiry) {\n          tokenExpiryTimeRef.current = parseInt(tokenExpiry);\n          scheduleTokenRefresh();\n        }\n        try {\n          const response = await fetch('http://localhost:5000/api/users/profile', {\n            method: 'GET',\n            headers: {\n              'Authorization': `Bearer ${accessToken}`\n            }\n          });\n          if (!response.ok) {\n            // Token inv√°lido, intentar refresh\n            await refreshToken();\n          } else {\n            // Actualizar usuario y tema desde backend\n            const data = await response.json();\n            const perfil = (data === null || data === void 0 ? void 0 : data.user) || data;\n            if (perfil) {\n              var _perfil$preferences;\n              setUser(perfil);\n              localStorage.setItem('user', JSON.stringify(perfil));\n              if (perfil !== null && perfil !== void 0 && (_perfil$preferences = perfil.preferences) !== null && _perfil$preferences !== void 0 && _perfil$preferences.theme) {\n                setTheme(perfil.preferences.theme);\n              }\n            }\n          }\n        } catch (error) {\n          console.error('Error verificando token:', error);\n          await logout();\n        }\n      }\n      setLoading(false);\n    };\n    initializeAuth();\n  }, []);\n\n  // ========================\n  // üîÅ Sincronizar logout entre pesta√±as\n  // ========================\n  useEffect(() => {\n    const syncLogout = e => {\n      if (e.key === 'logout_event') {\n        setUser(null);\n        localStorage.removeItem('user');\n        localStorage.removeItem('access_token');\n        localStorage.removeItem('refresh_token');\n        localStorage.removeItem('token_expiry');\n        // NO usar navigate aqu√≠, ProtectedRoutes lo manejar√°\n      }\n    };\n    window.addEventListener('storage', syncLogout);\n    return () => window.removeEventListener('storage', syncLogout);\n  }, []);\n\n  // ========================\n  // üîÑ REFRESH PROACTIVO (antes de que expire)\n  // ========================\n  const scheduleTokenRefresh = () => {\n    // Limpiar timer anterior\n    if (refreshTimerRef.current) {\n      clearTimeout(refreshTimerRef.current);\n    }\n    const expiryTime = tokenExpiryTimeRef.current;\n    if (!expiryTime) return;\n    const now = Date.now();\n    const timeUntilExpiry = expiryTime - now;\n    const timeUntilRefresh = timeUntilExpiry - REFRESH_BEFORE_EXPIRY;\n    console.log(`üïê Token expira en: ${Math.round(timeUntilExpiry / 1000)}s`);\n    console.log(`üîÑ Programando refresh en: ${Math.round(timeUntilRefresh / 1000)}s`);\n\n    // Solo programar refresh si tiene sentido (token a√∫n v√°lido y no cerca de expirar)\n    if (timeUntilRefresh > 0 && timeUntilExpiry > 0) {\n      refreshTimerRef.current = setTimeout(async () => {\n        console.log('üîÑ Ejecutando refresh proactivo...');\n        const success = await refreshToken();\n\n        // Si el refresh falla, no programar otro (evita loop infinito)\n        if (!success) {\n          console.log('‚ùå Refresh fall√≥, no se programa otro');\n        }\n      }, timeUntilRefresh);\n    } else if (timeUntilExpiry > 0 && timeUntilExpiry <= REFRESH_BEFORE_EXPIRY) {\n      // Token est√° muy cerca de expirar, refresh inmediato\n      console.log('‚ö†Ô∏è Token muy cerca de expirar, refresh inmediato');\n      refreshToken();\n    } else {\n      // Token ya expir√≥\n      console.log('‚ö†Ô∏è Token ya expir√≥');\n    }\n  };\n\n  // ========================\n  // üîí REFRESH CON LOCK (evita m√∫ltiples llamadas simult√°neas)\n  // ========================\n  const refreshToken = async () => {\n    // Si ya hay un refresh en progreso, esperar a que termine\n    if (isRefreshingRef.current && refreshPromiseRef.current) {\n      console.log('‚è≥ Refresh en progreso, esperando...');\n      return refreshPromiseRef.current;\n    }\n\n    // Marcar que estamos haciendo refresh\n    isRefreshingRef.current = true;\n    refreshPromiseRef.current = (async () => {\n      try {\n        const refreshToken = localStorage.getItem('refresh_token');\n        if (!refreshToken) {\n          console.log('‚ùå No hay refresh token');\n          await logout();\n          return false;\n        }\n        console.log('üîÑ Ejecutando refresh token...');\n        const response = await fetch('http://localhost:5000/api/auth/refresh', {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${refreshToken}`\n          }\n        });\n        const data = await response.json();\n        if (response.ok) {\n          console.log('‚úÖ Refresh exitoso');\n\n          // Guardar nuevos tokens\n          localStorage.setItem('access_token', data.access_token);\n          if (data.refresh_token) {\n            localStorage.setItem('refresh_token', data.refresh_token);\n          }\n\n          // Calcular y guardar tiempo de expiraci√≥n\n          const expiryTime = Date.now() + ACCESS_TOKEN_LIFETIME;\n          localStorage.setItem('token_expiry', expiryTime.toString());\n          tokenExpiryTimeRef.current = expiryTime;\n          if (data.user) {\n            // Evitar reiniciar timers por cambios de referencia del usuario durante refresh\n            if (!user) {\n              setUser(data.user);\n              localStorage.setItem('user', JSON.stringify(data.user));\n            }\n          }\n\n          // ‚úÖ CR√çTICO: Solo programar pr√≥ximo refresh si NO es un refresh proactivo repetitivo\n          // El pr√≥ximo refresh se programar√° solo cuando sea necesario (por authFetch o nuevo login)\n          console.log('‚úÖ Token renovado, NO se programa refresh autom√°tico adicional');\n          return true;\n        } else {\n          console.log('‚ùå Refresh fall√≥:', data.error);\n          await logout();\n          return false;\n        }\n      } catch (error) {\n        console.error('‚ùå Error en refresh:', error);\n        await logout();\n        return false;\n      } finally {\n        // Liberar el lock\n        isRefreshingRef.current = false;\n        refreshPromiseRef.current = null;\n      }\n    })();\n    return refreshPromiseRef.current;\n  };\n\n  // ========================\n  // ‚è∞ Control de inactividad (SEPARADO del refresh de token)\n  // ========================\n  useEffect(() => {\n    if (!user) return;\n    const resetInactivityTimers = () => {\n      // NO resetear si el modal ya est√° visible\n      if (sessionExpiringRef.current) return;\n      clearTimeout(inactivityTimerRef.current);\n      clearTimeout(totalSessionTimerRef.current);\n      clearInterval(countdownRef.current);\n      setSessionExpiring(false);\n      setCountdown(COUNTDOWN_SECONDS);\n      console.log('üîÑ Reset timers de inactividad', new Date().toLocaleTimeString());\n\n      // Timer para mostrar aviso\n      inactivityTimerRef.current = setTimeout(() => {\n        console.log('‚è≥ Mostrando aviso de inactividad');\n        setSessionExpiring(true);\n        // No iniciar conteo visual para evitar re-renders constantes\n      }, INACTIVITY_WARNING);\n\n      // Timer para logout autom√°tico\n      totalSessionTimerRef.current = setTimeout(() => {\n        console.log('üö™ Timeout alcanzado, cerrando sesi√≥n');\n        handleAutoLogout();\n      }, INACTIVITY_TIMEOUT);\n    };\n    const startCountdown = () => {\n      // Eliminado conteo visual para evitar re-render de toda la app\n      // El cierre autom√°tico lo maneja totalSessionTimerRef\n      clearInterval(countdownRef.current);\n    };\n    const handleAutoLogout = async () => {\n      console.log('üö™ Logout autom√°tico por inactividad');\n      clearInterval(countdownRef.current);\n      setSessionExpiring(false);\n      await logout();\n    };\n    const handleUserActivity = () => {\n      // Si el modal est√° visible, NO resetear\n      if (sessionExpiringRef.current) {\n        console.log('‚ö†Ô∏è Modal visible, ignorando actividad');\n        return;\n      }\n      // Throttle de eventos de actividad para evitar r√°fagas (mousemove/scroll)\n      const now = Date.now();\n      if (now - lastActivityTimeRef.current < 1000) return;\n      lastActivityTimeRef.current = now;\n      resetInactivityTimers();\n    };\n\n    // Suscribir eventos de actividad\n    window.addEventListener('mousemove', handleUserActivity);\n    window.addEventListener('keydown', handleUserActivity);\n    window.addEventListener('scroll', handleUserActivity);\n    window.addEventListener('click', handleUserActivity);\n\n    // Inicializar timers\n    resetInactivityTimers();\n    return () => {\n      window.removeEventListener('mousemove', handleUserActivity);\n      window.removeEventListener('keydown', handleUserActivity);\n      window.removeEventListener('scroll', handleUserActivity);\n      window.removeEventListener('click', handleUserActivity);\n      clearTimeout(inactivityTimerRef.current);\n      clearTimeout(totalSessionTimerRef.current);\n      clearInterval(countdownRef.current);\n    };\n  }, [!!user]);\n\n  // ========================\n  // üîÅ Extender sesi√≥n (bot√≥n \"Mantener sesi√≥n\")\n  // ========================\n  const extendSession = useCallback(() => {\n    console.log('‚úÖ Usuario extendi√≥ la sesi√≥n manualmente');\n\n    // Ocultar modal y resetear countdown\n    setSessionExpiring(false);\n    setCountdown(COUNTDOWN_SECONDS);\n\n    // Limpiar timers de inactividad\n    clearTimeout(inactivityTimerRef.current);\n    clearTimeout(totalSessionTimerRef.current);\n    clearInterval(countdownRef.current);\n\n    // Reiniciar timers desde cero\n    console.log('üîÑ Reiniciando timers de inactividad');\n    inactivityTimerRef.current = setTimeout(() => {\n      console.log('‚è≥ Mostrando aviso de inactividad');\n      setSessionExpiring(true);\n      // Sin conteo visual\n    }, INACTIVITY_WARNING);\n    totalSessionTimerRef.current = setTimeout(async () => {\n      console.log('üö™ Timeout alcanzado despu√©s de extender sesi√≥n');\n      clearInterval(countdownRef.current);\n      setSessionExpiring(false);\n      await logout();\n    }, INACTIVITY_TIMEOUT);\n  }, [INACTIVITY_WARNING, INACTIVITY_TIMEOUT]);\n\n  // ========================\n  // üîê Login\n  // ========================\n  const login = useCallback(async (email, password) => {\n    try {\n      const response = await fetch('http://localhost:5000/api/auth/login', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          email,\n          password\n        })\n      });\n      const data = await response.json();\n      if (response.ok) {\n        var _data$user, _data$user$preference;\n        // Guardar tokens\n        localStorage.setItem('access_token', data.access_token);\n        localStorage.setItem('refresh_token', data.refresh_token);\n        localStorage.setItem('user', JSON.stringify(data.user));\n\n        // Guardar tiempo de expiraci√≥n\n        const expiryTime = Date.now() + ACCESS_TOKEN_LIFETIME;\n        localStorage.setItem('token_expiry', expiryTime.toString());\n        tokenExpiryTimeRef.current = expiryTime;\n        setUser(data.user);\n        // Aplicar tema preferido del usuario si existe\n        if ((_data$user = data.user) !== null && _data$user !== void 0 && (_data$user$preference = _data$user.preferences) !== null && _data$user$preference !== void 0 && _data$user$preference.theme) {\n          setTheme(data.user.preferences.theme);\n        }\n\n        // Programar refresh proactivo\n        scheduleTokenRefresh();\n        return {\n          success: true,\n          user: data.user\n        };\n      } else {\n        return {\n          success: false,\n          error: data.error || 'Error en el login'\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: 'Error de conexi√≥n con el servidor'\n      };\n    }\n  }, [ACCESS_TOKEN_LIFETIME, setTheme]);\n\n  // ========================\n  // üö™ Logout\n  // ========================\n  const logout = useCallback(async () => {\n    try {\n      setSessionExpiring(false);\n\n      // Limpiar todos los timers\n      clearTimeout(refreshTimerRef.current);\n      clearTimeout(inactivityTimerRef.current);\n      clearTimeout(totalSessionTimerRef.current);\n      clearInterval(countdownRef.current);\n      const token = localStorage.getItem('access_token');\n      if (token) {\n        await fetch('http://localhost:5000/api/auth/logout', {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${token}`\n          }\n        });\n      }\n    } catch (error) {\n      console.error('Error durante logout:', error);\n    } finally {\n      setUser(null);\n      localStorage.removeItem('user');\n      localStorage.removeItem('access_token');\n      localStorage.removeItem('refresh_token');\n      localStorage.removeItem('token_expiry');\n      // Mantener app-theme en localStorage para no perder el tema local\n      localStorage.setItem('logout_event', Date.now());\n\n      // Resetear refs\n      isRefreshingRef.current = false;\n      refreshPromiseRef.current = null;\n      tokenExpiryTimeRef.current = null;\n\n      // ProtectedRoutes en App.js detectar√° user=null y redirigir√° a /login\n    }\n  }, []);\n\n  // ========================\n  // üîë hasPermission\n  // ========================\n  const hasPermission = useCallback(permission => {\n    if (!user || !user.permissions) return false;\n    return user.permissions.includes(permission);\n  }, [user]);\n\n  // ========================\n  // üåê authFetch con lock anti-race-condition\n  // ========================\n  const authFetch = useCallback(async (url, options = {}) => {\n    let token = localStorage.getItem('access_token');\n    const config = {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n        'Authorization': `Bearer ${token}`\n      }\n    };\n    let response = await fetch(url, config);\n\n    // Si el token expir√≥ (401), intentar refresh UNA VEZ\n    if (response.status === 401) {\n      console.log('üîÑ Token expirado, intentando refresh...');\n      const refreshed = await refreshToken();\n      if (refreshed) {\n        // Reintentar request con nuevo token\n        token = localStorage.getItem('access_token');\n        config.headers.Authorization = `Bearer ${token}`;\n        response = await fetch(url, config);\n      }\n    }\n    return response;\n  }, []);\n  const contextValue = useMemo(() => ({\n    user,\n    login,\n    logout,\n    hasPermission,\n    loading,\n    authFetch,\n    extendSession\n  }), [user, login, logout, hasPermission, loading, authFetch, extendSession]);\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: contextValue,\n    children: [/*#__PURE__*/_jsxDEV(ChildrenContainer, {\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 492,\n      columnNumber: 7\n    }, this), sessionExpiring && /*#__PURE__*/createPortal(/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999]\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"bg-white p-6 rounded-2xl shadow-lg text-center max-w-sm\",\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          className: \"text-lg font-semibold mb-2 text-gray-800\",\n          children: \"Sesi\\xF3n a punto de expirar\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 498,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-gray-600 mb-4\",\n          children: [\"Tu sesi\\xF3n se cerrar\\xE1 autom\\xE1ticamente en \", COUNTDOWN_SECONDS, \" segundos por inactividad.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 501,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"flex justify-center gap-4\",\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: extendSession,\n            className: \"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\",\n            children: \"Mantener sesi\\xF3n\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 505,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: logout,\n            className: \"px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400\",\n            children: \"Cerrar ahora\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 511,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 504,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 497,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 496,\n      columnNumber: 9\n    }, this), document.body)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 491,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"Zz7HtQmOWSmd+WOPv/Ftea6uTOI=\", false, function () {\n  return [useTheme];\n});\n_c3 = AuthProvider;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"ChildrenContainer$React.memo\");\n$RefreshReg$(_c2, \"ChildrenContainer\");\n$RefreshReg$(_c3, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useRef","useMemo","useCallback","useTheme","createPortal","Fragment","_Fragment","jsxDEV","_jsxDEV","AuthContext","ChildrenContainer","memo","_c","children","_c2","useAuth","_s","AuthProvider","_s2","user","setUser","loading","setLoading","sessionExpiring","setSessionExpiring","setTheme","TIEMPO_CONFIG","TOKEN_DURACION","minutos","segundos","REFRESH_ANTICIPADO","AVISO_INACTIVIDAD","LOGOUT_INACTIVIDAD","aMs","config","ACCESS_TOKEN_LIFETIME","REFRESH_BEFORE_EXPIRY","INACTIVITY_WARNING","INACTIVITY_TIMEOUT","COUNTDOWN_SECONDS","Math","floor","countdown","setCountdown","countdownRef","inactivityTimerRef","totalSessionTimerRef","sessionExpiringRef","refreshTimerRef","isRefreshingRef","refreshPromiseRef","tokenExpiryTimeRef","lastActivityTimeRef","current","initializeAuth","savedUser","localStorage","getItem","accessToken","_parsed$preferences","parsed","JSON","parse","preferences","theme","tokenExpiry","parseInt","scheduleTokenRefresh","response","fetch","method","headers","ok","refreshToken","data","json","perfil","_perfil$preferences","setItem","stringify","error","console","logout","syncLogout","e","key","removeItem","window","addEventListener","removeEventListener","clearTimeout","expiryTime","now","Date","timeUntilExpiry","timeUntilRefresh","log","round","setTimeout","success","access_token","refresh_token","toString","resetInactivityTimers","clearInterval","toLocaleTimeString","handleAutoLogout","startCountdown","handleUserActivity","extendSession","login","email","password","body","_data$user","_data$user$preference","token","hasPermission","permission","permissions","includes","authFetch","url","options","status","refreshed","Authorization","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","className","onClick","document","_c3","$RefreshReg$"],"sources":["D:/Usuarios/FRANCO/Desktop/parroquav3/frontend/src/contexts/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, useRef, useMemo, useCallback } from 'react';\nimport { useTheme } from './ThemeContext';\nimport { createPortal } from 'react-dom';\n\nconst AuthContext = createContext();\n// Evita re-render de la app cuando el Provider cambia estado interno no relevante\nconst ChildrenContainer = React.memo(({ children }) => <>{children}</>);\n\nexport const useAuth = () => useContext(AuthContext);\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [sessionExpiring, setSessionExpiring] = useState(false);\n  const { setTheme } = useTheme();\n\n  // ‚öôÔ∏è CONFIGURACI√ìN DE TIEMPOS (m√°s legible)\n  // Formato: { minutos: X, segundos: Y }\n  const TIEMPO_CONFIG = {\n  TOKEN_DURACION: { minutos: 1, segundos: 0 },      // Igual que backend\n  REFRESH_ANTICIPADO: { minutos: 0, segundos: 10 }, // 10s antes de expirar\n  AVISO_INACTIVIDAD: { minutos: 0, segundos: 45 },  // Aviso a los 45s\n  LOGOUT_INACTIVIDAD: { minutos: 1, segundos: 0 }   // Logout a 1 min\n};\n\n  // üîß Funci√≥n helper para convertir a milisegundos\n  const aMs = (config) => (config.minutos * 60 + config.segundos) * 1000;\n\n  // Constantes calculadas (NO MODIFICAR)\n  const ACCESS_TOKEN_LIFETIME = aMs(TIEMPO_CONFIG.TOKEN_DURACION);\n  const REFRESH_BEFORE_EXPIRY = aMs(TIEMPO_CONFIG.REFRESH_ANTICIPADO);\n  const INACTIVITY_WARNING = aMs(TIEMPO_CONFIG.AVISO_INACTIVIDAD);\n  const INACTIVITY_TIMEOUT = aMs(TIEMPO_CONFIG.LOGOUT_INACTIVIDAD);\n  const COUNTDOWN_SECONDS = Math.floor((INACTIVITY_TIMEOUT - INACTIVITY_WARNING) / 1000);\n\n  const [countdown, setCountdown] = useState(COUNTDOWN_SECONDS);\n\n  // üîí REFS para control de estado y prevenci√≥n de race conditions\n  const countdownRef = useRef(null);\n  const inactivityTimerRef = useRef(null);\n  const totalSessionTimerRef = useRef(null);\n  const sessionExpiringRef = useRef(sessionExpiring);\n  const refreshTimerRef = useRef(null);\n  const isRefreshingRef = useRef(false);\n  const refreshPromiseRef = useRef(null);\n  const tokenExpiryTimeRef = useRef(null);\n  const lastActivityTimeRef = useRef(0);\n\n  useEffect(() => {\n    sessionExpiringRef.current = sessionExpiring;\n  }, [sessionExpiring]);\n\n  // ========================\n  // üü¢ Inicializaci√≥n de sesi√≥n\n  // ========================\n  useEffect(() => {\n    const initializeAuth = async () => {\n      const savedUser = localStorage.getItem('user');\n      const accessToken = localStorage.getItem('access_token');\n\n      if (savedUser && accessToken) {\n        try {\n          const parsed = JSON.parse(savedUser);\n          setUser(parsed);\n          // Aplica tema desde preferencias guardadas del usuario (si existen)\n          if (parsed?.preferences?.theme) {\n            setTheme(parsed.preferences.theme);\n          }\n        } catch {}\n        \n        // Establecer tiempo de expiraci√≥n del token\n        const tokenExpiry = localStorage.getItem('token_expiry');\n        if (tokenExpiry) {\n          tokenExpiryTimeRef.current = parseInt(tokenExpiry);\n          scheduleTokenRefresh();\n        }\n\n        try {\n          const response = await fetch('http://localhost:5000/api/users/profile', {\n            method: 'GET',\n            headers: { 'Authorization': `Bearer ${accessToken}` },\n          });\n          \n          if (!response.ok) {\n            // Token inv√°lido, intentar refresh\n            await refreshToken();\n          } else {\n            // Actualizar usuario y tema desde backend\n            const data = await response.json();\n            const perfil = data?.user || data;\n            if (perfil) {\n              setUser(perfil);\n              localStorage.setItem('user', JSON.stringify(perfil));\n              if (perfil?.preferences?.theme) {\n                setTheme(perfil.preferences.theme);\n              }\n            }\n          }\n        } catch (error) {\n          console.error('Error verificando token:', error);\n          await logout();\n        }\n      }\n      setLoading(false);\n    };\n\n    initializeAuth();\n  }, []);\n\n  // ========================\n  // üîÅ Sincronizar logout entre pesta√±as\n  // ========================\n  useEffect(() => {\n    const syncLogout = (e) => {\n      if (e.key === 'logout_event') {\n        setUser(null);\n        localStorage.removeItem('user');\n        localStorage.removeItem('access_token');\n        localStorage.removeItem('refresh_token');\n        localStorage.removeItem('token_expiry');\n        // NO usar navigate aqu√≠, ProtectedRoutes lo manejar√°\n      }\n    };\n    window.addEventListener('storage', syncLogout);\n    return () => window.removeEventListener('storage', syncLogout);\n  }, []);\n\n  // ========================\n  // üîÑ REFRESH PROACTIVO (antes de que expire)\n  // ========================\n  const scheduleTokenRefresh = () => {\n    // Limpiar timer anterior\n    if (refreshTimerRef.current) {\n      clearTimeout(refreshTimerRef.current);\n    }\n\n    const expiryTime = tokenExpiryTimeRef.current;\n    if (!expiryTime) return;\n\n    const now = Date.now();\n    const timeUntilExpiry = expiryTime - now;\n    const timeUntilRefresh = timeUntilExpiry - REFRESH_BEFORE_EXPIRY;\n\n    console.log(`üïê Token expira en: ${Math.round(timeUntilExpiry / 1000)}s`);\n    console.log(`üîÑ Programando refresh en: ${Math.round(timeUntilRefresh / 1000)}s`);\n\n    // Solo programar refresh si tiene sentido (token a√∫n v√°lido y no cerca de expirar)\n    if (timeUntilRefresh > 0 && timeUntilExpiry > 0) {\n      refreshTimerRef.current = setTimeout(async () => {\n        console.log('üîÑ Ejecutando refresh proactivo...');\n        const success = await refreshToken();\n        \n        // Si el refresh falla, no programar otro (evita loop infinito)\n        if (!success) {\n          console.log('‚ùå Refresh fall√≥, no se programa otro');\n        }\n      }, timeUntilRefresh);\n    } else if (timeUntilExpiry > 0 && timeUntilExpiry <= REFRESH_BEFORE_EXPIRY) {\n      // Token est√° muy cerca de expirar, refresh inmediato\n      console.log('‚ö†Ô∏è Token muy cerca de expirar, refresh inmediato');\n      refreshToken();\n    } else {\n      // Token ya expir√≥\n      console.log('‚ö†Ô∏è Token ya expir√≥');\n    }\n  };\n\n  // ========================\n  // üîí REFRESH CON LOCK (evita m√∫ltiples llamadas simult√°neas)\n  // ========================\n  const refreshToken = async () => {\n    // Si ya hay un refresh en progreso, esperar a que termine\n    if (isRefreshingRef.current && refreshPromiseRef.current) {\n      console.log('‚è≥ Refresh en progreso, esperando...');\n      return refreshPromiseRef.current;\n    }\n\n    // Marcar que estamos haciendo refresh\n    isRefreshingRef.current = true;\n    \n    refreshPromiseRef.current = (async () => {\n      try {\n        const refreshToken = localStorage.getItem('refresh_token');\n        if (!refreshToken) {\n          console.log('‚ùå No hay refresh token');\n          await logout();\n          return false;\n        }\n\n        console.log('üîÑ Ejecutando refresh token...');\n        const response = await fetch('http://localhost:5000/api/auth/refresh', {\n          method: 'POST',\n          headers: { 'Authorization': `Bearer ${refreshToken}` },\n        });\n\n        const data = await response.json();\n\n        if (response.ok) {\n          console.log('‚úÖ Refresh exitoso');\n          \n          // Guardar nuevos tokens\n          localStorage.setItem('access_token', data.access_token);\n          \n          if (data.refresh_token) {\n            localStorage.setItem('refresh_token', data.refresh_token);\n          }\n          \n          // Calcular y guardar tiempo de expiraci√≥n\n          const expiryTime = Date.now() + ACCESS_TOKEN_LIFETIME;\n          localStorage.setItem('token_expiry', expiryTime.toString());\n          tokenExpiryTimeRef.current = expiryTime;\n          \n          if (data.user) {\n            // Evitar reiniciar timers por cambios de referencia del usuario durante refresh\n            if (!user) {\n              setUser(data.user);\n              localStorage.setItem('user', JSON.stringify(data.user));\n            }\n          }\n\n          // ‚úÖ CR√çTICO: Solo programar pr√≥ximo refresh si NO es un refresh proactivo repetitivo\n          // El pr√≥ximo refresh se programar√° solo cuando sea necesario (por authFetch o nuevo login)\n          console.log('‚úÖ Token renovado, NO se programa refresh autom√°tico adicional');\n          \n          return true;\n        } else {\n          console.log('‚ùå Refresh fall√≥:', data.error);\n          await logout();\n          return false;\n        }\n      } catch (error) {\n        console.error('‚ùå Error en refresh:', error);\n        await logout();\n        return false;\n      } finally {\n        // Liberar el lock\n        isRefreshingRef.current = false;\n        refreshPromiseRef.current = null;\n      }\n    })();\n\n    return refreshPromiseRef.current;\n  };\n\n  // ========================\n  // ‚è∞ Control de inactividad (SEPARADO del refresh de token)\n  // ========================\n  useEffect(() => {\n    if (!user) return;\n\n    const resetInactivityTimers = () => {\n      // NO resetear si el modal ya est√° visible\n      if (sessionExpiringRef.current) return;\n\n      clearTimeout(inactivityTimerRef.current);\n      clearTimeout(totalSessionTimerRef.current);\n      clearInterval(countdownRef.current);\n      setSessionExpiring(false);\n      setCountdown(COUNTDOWN_SECONDS);\n\n      console.log('üîÑ Reset timers de inactividad', new Date().toLocaleTimeString());\n\n      // Timer para mostrar aviso\n      inactivityTimerRef.current = setTimeout(() => {\n        console.log('‚è≥ Mostrando aviso de inactividad');\n        setSessionExpiring(true);\n        // No iniciar conteo visual para evitar re-renders constantes\n      }, INACTIVITY_WARNING);\n\n      // Timer para logout autom√°tico\n      totalSessionTimerRef.current = setTimeout(() => {\n        console.log('üö™ Timeout alcanzado, cerrando sesi√≥n');\n        handleAutoLogout();\n      }, INACTIVITY_TIMEOUT);\n    };\n\n    const startCountdown = () => {\n      // Eliminado conteo visual para evitar re-render de toda la app\n      // El cierre autom√°tico lo maneja totalSessionTimerRef\n      clearInterval(countdownRef.current);\n    };\n\n    const handleAutoLogout = async () => {\n      console.log('üö™ Logout autom√°tico por inactividad');\n      clearInterval(countdownRef.current);\n      setSessionExpiring(false);\n      await logout();\n    };\n\n    const handleUserActivity = () => {\n      // Si el modal est√° visible, NO resetear\n      if (sessionExpiringRef.current) {\n        console.log('‚ö†Ô∏è Modal visible, ignorando actividad');\n        return;\n      }\n      // Throttle de eventos de actividad para evitar r√°fagas (mousemove/scroll)\n      const now = Date.now();\n      if (now - lastActivityTimeRef.current < 1000) return;\n      lastActivityTimeRef.current = now;\n      resetInactivityTimers();\n    };\n\n    // Suscribir eventos de actividad\n    window.addEventListener('mousemove', handleUserActivity);\n    window.addEventListener('keydown', handleUserActivity);\n    window.addEventListener('scroll', handleUserActivity);\n    window.addEventListener('click', handleUserActivity);\n\n    // Inicializar timers\n    resetInactivityTimers();\n\n    return () => {\n      window.removeEventListener('mousemove', handleUserActivity);\n      window.removeEventListener('keydown', handleUserActivity);\n      window.removeEventListener('scroll', handleUserActivity);\n      window.removeEventListener('click', handleUserActivity);\n\n      clearTimeout(inactivityTimerRef.current);\n      clearTimeout(totalSessionTimerRef.current);\n      clearInterval(countdownRef.current);\n    };\n  }, [!!user]);\n\n  // ========================\n  // üîÅ Extender sesi√≥n (bot√≥n \"Mantener sesi√≥n\")\n  // ========================\n  const extendSession = useCallback(() => {\n    console.log('‚úÖ Usuario extendi√≥ la sesi√≥n manualmente');\n    \n    // Ocultar modal y resetear countdown\n    setSessionExpiring(false);\n    setCountdown(COUNTDOWN_SECONDS);\n    \n    // Limpiar timers de inactividad\n    clearTimeout(inactivityTimerRef.current);\n    clearTimeout(totalSessionTimerRef.current);\n    clearInterval(countdownRef.current);\n\n    // Reiniciar timers desde cero\n    console.log('üîÑ Reiniciando timers de inactividad');\n    \n    inactivityTimerRef.current = setTimeout(() => {\n      console.log('‚è≥ Mostrando aviso de inactividad');\n      setSessionExpiring(true);\n      // Sin conteo visual\n    }, INACTIVITY_WARNING);\n\n    totalSessionTimerRef.current = setTimeout(async () => {\n      console.log('üö™ Timeout alcanzado despu√©s de extender sesi√≥n');\n      clearInterval(countdownRef.current);\n      setSessionExpiring(false);\n      await logout();\n    }, INACTIVITY_TIMEOUT);\n  }, [INACTIVITY_WARNING, INACTIVITY_TIMEOUT]);\n\n  // ========================\n  // üîê Login\n  // ========================\n  const login = useCallback(async (email, password) => {\n    try {\n      const response = await fetch('http://localhost:5000/api/auth/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email, password }),\n      });\n\n      const data = await response.json();\n\n      if (response.ok) {\n        // Guardar tokens\n        localStorage.setItem('access_token', data.access_token);\n        localStorage.setItem('refresh_token', data.refresh_token);\n        localStorage.setItem('user', JSON.stringify(data.user));\n        \n        // Guardar tiempo de expiraci√≥n\n        const expiryTime = Date.now() + ACCESS_TOKEN_LIFETIME;\n        localStorage.setItem('token_expiry', expiryTime.toString());\n        tokenExpiryTimeRef.current = expiryTime;\n        \n        setUser(data.user);\n        // Aplicar tema preferido del usuario si existe\n        if (data.user?.preferences?.theme) {\n          setTheme(data.user.preferences.theme);\n        }\n        \n        // Programar refresh proactivo\n        scheduleTokenRefresh();\n        \n        return { success: true, user: data.user };\n      } else {\n        return { success: false, error: data.error || 'Error en el login' };\n      }\n    } catch (error) {\n      return { success: false, error: 'Error de conexi√≥n con el servidor' };\n    }\n  }, [ACCESS_TOKEN_LIFETIME, setTheme]);\n\n  // ========================\n  // üö™ Logout\n  // ========================\n  const logout = useCallback(async () => {\n    try {\n      setSessionExpiring(false);\n      \n      // Limpiar todos los timers\n      clearTimeout(refreshTimerRef.current);\n      clearTimeout(inactivityTimerRef.current);\n      clearTimeout(totalSessionTimerRef.current);\n      clearInterval(countdownRef.current);\n\n      const token = localStorage.getItem('access_token');\n      if (token) {\n        await fetch('http://localhost:5000/api/auth/logout', {\n          method: 'POST',\n          headers: { 'Authorization': `Bearer ${token}` },\n        });\n      }\n    } catch (error) {\n      console.error('Error durante logout:', error);\n    } finally {\n      setUser(null);\n      localStorage.removeItem('user');\n      localStorage.removeItem('access_token');\n      localStorage.removeItem('refresh_token');\n      localStorage.removeItem('token_expiry');\n      // Mantener app-theme en localStorage para no perder el tema local\n      localStorage.setItem('logout_event', Date.now());\n      \n      // Resetear refs\n      isRefreshingRef.current = false;\n      refreshPromiseRef.current = null;\n      tokenExpiryTimeRef.current = null;\n      \n      // ProtectedRoutes en App.js detectar√° user=null y redirigir√° a /login\n    }\n  }, []);\n\n  // ========================\n  // üîë hasPermission\n  // ========================\n  const hasPermission = useCallback((permission) => {\n    if (!user || !user.permissions) return false;\n    return user.permissions.includes(permission);\n  }, [user]);\n\n  // ========================\n  // üåê authFetch con lock anti-race-condition\n  // ========================\n  const authFetch = useCallback(async (url, options = {}) => {\n    let token = localStorage.getItem('access_token');\n\n    const config = {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n        'Authorization': `Bearer ${token}`,\n      },\n    };\n\n    let response = await fetch(url, config);\n\n    // Si el token expir√≥ (401), intentar refresh UNA VEZ\n    if (response.status === 401) {\n      console.log('üîÑ Token expirado, intentando refresh...');\n      \n      const refreshed = await refreshToken();\n      \n      if (refreshed) {\n        // Reintentar request con nuevo token\n        token = localStorage.getItem('access_token');\n        config.headers.Authorization = `Bearer ${token}`;\n        response = await fetch(url, config);\n      }\n    }\n\n    return response;\n  }, []);\n\n  const contextValue = useMemo(() => ({\n    user,\n    login,\n    logout,\n    hasPermission,\n    loading,\n    authFetch,\n    extendSession\n  }), [user, login, logout, hasPermission, loading, authFetch, extendSession]);\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      <ChildrenContainer>{children}</ChildrenContainer>\n\n      {/* üîî Modal de inactividad en Portal para aislar del √°rbol principal */}\n      {sessionExpiring && createPortal(\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999]\">\n          <div className=\"bg-white p-6 rounded-2xl shadow-lg text-center max-w-sm\">\n            <h2 className=\"text-lg font-semibold mb-2 text-gray-800\">\n              Sesi√≥n a punto de expirar\n            </h2>\n            <p className=\"text-gray-600 mb-4\">\n              Tu sesi√≥n se cerrar√° autom√°ticamente en {COUNTDOWN_SECONDS} segundos por inactividad.\n            </p>\n            <div className=\"flex justify-center gap-4\">\n              <button\n                onClick={extendSession}\n                className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n              >\n                Mantener sesi√≥n\n              </button>\n              <button\n                onClick={logout}\n                className=\"px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400\"\n              >\n                Cerrar ahora\n              </button>\n            </div>\n          </div>\n        </div>,\n        document.body\n      )}\n    </AuthContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}